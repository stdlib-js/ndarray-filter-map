{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isPlainObject from '@stdlib/assert-is-plain-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport isOrder from '@stdlib/ndarray-base-assert-is-order';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport ctors from '@stdlib/ndarray-base-buffer-ctors';\nimport zeros from '@stdlib/array-base-zeros';\nimport getShape from '@stdlib/ndarray-shape';\nimport getDType from '@stdlib/ndarray-dtype';\nimport getOrder from '@stdlib/ndarray-order';\nimport numel from '@stdlib/ndarray-base-numel';\nimport { assign as nextCartesianIndex } from '@stdlib/ndarray-base-next-cartesian-index';\nimport gcopy from '@stdlib/blas-base-gcopy';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Filters and maps elements in an input ndarray to elements in a new output ndarray according to a callback function.\n*\n* @param {ndarray} x - input ndarray\n* @param {Options} [options] - function options\n* @param {string} [options.dtype] - output array data type\n* @param {string} [options.order] - index iteration order\n* @param {Callback} fcn - callback function\n* @param {*} [thisArg] - callback execution context\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} callback argument must be a function\n* @throws {TypeError} options argument must be an object\n* @returns {ndarray} output ndarray\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray from '@stdlib/ndarray-ctor';\n* import ndarray2array from '@stdlib/ndarray-to-array';\n*\n* function fcn( v ) {\n*     if ( v > 5.0 ) {\n*         return v * 10.0;\n*     }\n* }\n*\n* var buffer = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var shape = [ 2, 3 ];\n* var strides = [ 6, 1 ];\n* var offset = 1;\n*\n* var x = ndarray( 'float64', buffer, shape, strides, offset, 'row-major' );\n* // returns <ndarray>\n*\n* var y = filterMap( x, fcn );\n* // returns <ndarray>\n*\n* var arr = ndarray2array( y );\n* // returns [ 80.0, 90.0, 100.0 ]\n*/\nfunction filterMap( x, options, fcn, thisArg ) {\n\tvar hasOpts;\n\tvar ndims;\n\tvar cache;\n\tvar clbk;\n\tvar opts;\n\tvar ctor;\n\tvar ctx;\n\tvar ord;\n\tvar dim;\n\tvar idx;\n\tvar buf;\n\tvar dt;\n\tvar sh;\n\tvar N;\n\tvar y;\n\tvar v;\n\tvar i;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'null5t', x ) );\n\t}\n\tif ( arguments.length < 3 ) {\n\t\tclbk = options;\n\t} else if ( arguments.length === 3 ) {\n\t\tif ( isFunction( options ) ) {\n\t\t\tclbk = options;\n\t\t\tctx = fcn;\n\t\t} else {\n\t\t\thasOpts = true;\n\t\t\topts = options;\n\t\t\tclbk = fcn;\n\t\t}\n\t} else {\n\t\thasOpts = true;\n\t\topts = options;\n\t\tclbk = fcn;\n\t\tctx = thisArg;\n\t}\n\tif ( !isFunction( clbk ) ) {\n\t\tthrow new TypeError( format( 'null2b', clbk ) );\n\t}\n\tif ( hasOpts ) {\n\t\tif ( !isPlainObject( opts ) ) {\n\t\t\tthrow new TypeError( format( 'null2V', opts ) );\n\t\t}\n\t\tif ( hasOwnProp( opts, 'dtype' ) ) {\n\t\t\tdt = opts.dtype;\n\t\t} else {\n\t\t\tdt = getDType( x );\n\t\t}\n\t\tif ( hasOwnProp( opts, 'order' ) ) {\n\t\t\tif ( !isOrder( opts.order ) ) {\n\t\t\t\tthrow new TypeError( format( 'null5C', 'order', opts.order ) );\n\t\t\t}\n\t\t\tord = opts.order;\n\t\t}\n\t} else {\n\t\tdt = getDType( x );\n\t}\n\t// Resolve an output array buffer constructor:\n\tctor = ctors( dt );\n\tif ( ctor === null ) {\n\t\t// The only way we should get here is if the user provided an unsupported data type, as `getDType` should error if the input array has an unrecognized/unsupported data type...\n\t\tthrow new TypeError( format( 'nullBf', 'dtype', opts.dtype ) );\n\t}\n\t// Resolve the iteration order:\n\tif ( ord === void 0 ) {\n\t\tord = getOrder( x );\n\t}\n\t// Resolve the input array shape:\n\tsh = getShape( x );\n\n\t// Compute the number of array elements:\n\tN = numel( sh );\n\n\t// Retrieve the number of dimensions:\n\tndims = sh.length;\n\n\t// Resolve the dimension in which indices should iterate fastest:\n\tif ( ord === 'row-major' ) {\n\t\tdim = ndims - 1;\n\t} else { // ord === 'column-major'\n\t\tdim = 0;\n\t}\n\t// Initialize an index array workspace:\n\tidx = zeros( ndims );\n\n\t// Initialize a value cache for those elements which pass a callback function (note: unfortunately, we use an associative array here, as no other good options. If we use a \"generic\" array, we are limited to 2^32-1 elements. If we allocate, say, a Float64Array buffer for storing indices, we risk materializing lazily-materialized input ndarray values again (e.g., lazy accessor ndarray), which could be expensive. If we allocate a workspace buffer of equal size to the input ndarray to store materialized values, we'd then need to perform another copy in order to shrink the buffer, as, otherwise, could be holding on to significantly more memory than needed for the returned ndarray. There are likely other options, but all involve complexity, so the simplest option is used here.):\n\tcache = {\n\t\t'length': 0\n\t};\n\n\t// Filter and map elements according to a callback function...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( i > 0 ) {\n\t\t\tidx = nextCartesianIndex( sh, ord, idx, dim, idx );\n\t\t}\n\t\tv = clbk.call( ctx, x.get.apply( x, idx ), idx.slice(), x );\n\t\tif ( v !== void 0 ) {\n\t\t\tcache[ cache.length ] = v;\n\t\t\tcache.length += 1;\n\t\t}\n\t}\n\t// Retrieve the number of cached elements:\n\tN = cache.length;\n\n\t// Allocate an output array buffer:\n\tbuf = new ctor( N );\n\n\t// Copy cached elements to the output array buffer:\n\tgcopy( N, cache, 1, buf, 1 );\n\n\t// Create an output ndarray:\n\ty = new x.constructor( dt, buf, [ N ], [ 1 ], 0, ord );\n\n\treturn y;\n}\n\n\n// EXPORTS //\n\nexport default filterMap;\n"],"names":["filterMap","x","options","fcn","thisArg","hasOpts","ndims","cache","clbk","opts","ctor","ctx","ord","dim","idx","buf","dt","sh","N","v","i","isndarrayLike","TypeError","format","arguments","length","isFunction","isPlainObject","hasOwnProp","dtype","getDType","isOrder","order","ctors","getOrder","getShape","numel","zeros","nextCartesianIndex","call","get","apply","slice","gcopy","constructor"],"mappings":";;6zCA+EA,SAASA,EAAWC,EAAGC,EAASC,EAAKC,GACpC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEAC,EACAC,EACJ,IAAMC,EAAepB,GACpB,MAAM,IAAIqB,UAAWC,EAAQ,SAAUtB,IAmBxC,GAjBKuB,UAAUC,OAAS,EACvBjB,EAAON,EACyB,IAArBsB,UAAUC,OAChBC,EAAYxB,IAChBM,EAAON,EACPS,EAAMR,IAENE,GAAU,EACVI,EAAOP,EACPM,EAAOL,IAGRE,GAAU,EACVI,EAAOP,EACPM,EAAOL,EACPQ,EAAMP,IAEDsB,EAAYlB,GACjB,MAAM,IAAIc,UAAWC,EAAQ,SAAUf,IAExC,GAAKH,EAAU,CACd,IAAMsB,EAAelB,GACpB,MAAM,IAAIa,UAAWC,EAAQ,SAAUd,IAOxC,GAJCO,EADIY,EAAYnB,EAAM,SACjBA,EAAKoB,MAELC,EAAU7B,GAEX2B,EAAYnB,EAAM,SAAY,CAClC,IAAMsB,EAAStB,EAAKuB,OACnB,MAAM,IAAIV,UAAWC,EAAQ,SAAU,QAASd,EAAKuB,QAEtDpB,EAAMH,EAAKuB,KACX,CACH,MACEhB,EAAKc,EAAU7B,GAIhB,GAAc,QADdS,EAAOuB,EAAOjB,IAGb,MAAM,IAAIM,UAAWC,EAAQ,SAAU,QAASd,EAAKoB,QA8BtD,SA3Ba,IAARjB,IACJA,EAAMsB,EAAUjC,IAGjBgB,EAAKkB,EAAUlC,GAGfiB,EAAIkB,EAAOnB,GAGXX,EAAQW,EAAGQ,OAIVZ,EADY,cAARD,EACEN,EAAQ,EAER,EAGPQ,EAAMuB,EAAO/B,GAGbC,EAAQ,CACPkB,OAAU,GAILL,EAAI,EAAGA,EAAIF,EAAGE,IACdA,EAAI,IACRN,EAAMwB,EAAoBrB,EAAIL,EAAKE,EAAKD,EAAKC,SAGnC,KADXK,EAAIX,EAAK+B,KAAM5B,EAAKV,EAAEuC,IAAIC,MAAOxC,EAAGa,GAAOA,EAAI4B,QAASzC,MAEvDM,EAAOA,EAAMkB,QAAWN,EACxBZ,EAAMkB,QAAU,GAelB,OARAV,EAAM,IAAIL,EAHVQ,EAAIX,EAAMkB,QAMVkB,EAAOzB,EAAGX,EAAO,EAAGQ,EAAK,GAGrB,IAAId,EAAE2C,YAAa5B,EAAID,EAAK,CAAEG,GAAK,CAAE,GAAK,EAAGN,EAGlD"}